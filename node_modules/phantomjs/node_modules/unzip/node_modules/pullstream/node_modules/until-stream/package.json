{
  "name": "until-stream",
  "version": "0.2.2",
  "description": "A PassThrough stream that stops piping when a pattern is reached ",
  "main": "until.js",
  "scripts": {
    "test": "./node_modules/.bin/tap ./test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/EvanOxfeld/until-stream.git"
  },
  "keywords": [
    "until",
    "when",
    "split",
    "pause",
    "stream",
    "pipe",
    "pull"
  ],
  "author": {
    "name": "Evan Oxfeld",
    "email": "eoxfeld@gmail.com"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "babb2bd6e42172fcbed4581049ae62ae6d68b3a6",
  "devDependencies": {
    "tap": "~0.4.0",
    "stream-buffers": "~0.2.4"
  },
  "dependencies": {
    "buffers": "~0.1.1",
    "readable-stream": "~1.0.0",
    "setimmediate": "~1.0.1"
  },
  "readme": "until-stream [![Build Status](https://travis-ci.org/EvanOxfeld/until-stream.png)](https://travis-ci.org/EvanOxfeld/until-stream)\n============\n\nEver wanted to pause a stream when a certain String or\na binary signature is reached? UntilStream is the\nanswer. Pipe UntilStream and automatically stop when\nyour pattern is reached or call read() until the returned\ndata matches your pattern, without excessively buffering\nyour stream's content in memory.\n\n<pre>\n--------------------------------------\n|Stability - API is somewhat unstable|\n--------------------------------------\n</pre>\nread() and pipe() are implemented with some limitations.\nFor example, UntilStream supports piping to only a\nsingle destination stream.\n\n## Installation\n\n```bash\n$ npm install until-stream\n```\n\n## Quick Examples\n\n### Pipe\n\n```javascript\nvar UntilStream = require('until-stream');\nvar streamBuffers = require(\"stream-buffers\");\n\nvar us = new UntilStream({ pattern: 'World'});\n\nvar sourceStream = new streamBuffers.ReadableStreamBuffer();\nsourceStream.put(\"Hello World\");\nvar writableStream = new streamBuffers.WritableStreamBuffer();\n\nsourceStream.pipe(us).pipe(writableStream);\n\nwritableStream.once('close', function () {\n  //writeableStream contains all data before the pattern occurs\n  var str = writableStream.getContentsAsString('utf8'); // 'Hello '\n  //Now the next call to read() returns the pattern\n  var data = us.read(); // 'World'\n});\n```\n### Read\n\n```javascript\nvar UntilStream = require('until-stream');\nvar streamBuffers = require(\"stream-buffers\");\n\nvar us = new UntilStream({ pattern: 'jumps'});\n\nvar sourceStream = new streamBuffers.ReadableStreamBuffer({ chunkSize: 8 });\nsourceStream.put(\"The quick brown fox jumps over the lazy dog\");\n\nsourceStream.pipe(us);\n\nus.on('readable', function() {\n  if (us.read() === 'jumps') {\n    console.log('Pattern reached!');\n  }\n});\n```\n\n# API Index\n\n## UntilStream\n * [new UntilStream([options])](#untilStreamConstructor)\n * [read([size])](#untilStreamRead)\n * [pipe(destination, [options])](#untilStreamPipe)\n * [reconfigure([options])](#untilStreamReconfigure)\n\nUntilStream also includes stream.Readable and\nstream.Writable methods. See the node v0.9 [Stream documentation]\n(http://nodejs.org/docs/v0.9.10/api/stream.html) for more.\n\n# API Documentation\n\n<a name=\"untilStream\"/>\n## UntilStream\n\n<a name=\"untilStreamConstructor\" />\n### new UntilStream([options])\n\n__Arguments__\n\n* options (optional)\n    * pattern - String or Buffer If provided, UntilStream will\n                stop reads or pipes when reached\n\n<a name=\"untilStreamRead\" />\n### us.read([size])\n\nSynchronously consume data from UntilStream's internal\nbuffer. If the specified pattern is detected within the\ncurrent chunk, slice off the portion prior to the pattern.\nThe next call to read() will return exactly the pattern.\nOtherwise return the current chunk.\n\n__Arguments__\n\n* size (optional) - Mininum number of bytes to read. If not\n                    specified return the entire content of\n                    the internal buffer or up to the pattern\n\n__Return__\n\nBuffer | null\n\n__Example__\n\n```javascript\nvar us = new UntilStream({ pattern: '\\n' });\n\nus.write(\"Hello\\nWorld\");\nvar hello = us.read();\nconsole.log(hello.toString('utf8'));\nus.read(); //matches '\\n' pattern!\nvar world = us.read();\nconsole.log(world.toString('utf8'));\n```\n\n<a name=\"untilStreamPipe\" />\n### us.pipe(destination, [options])\n\nPipe incoming data from UntilStream to the destination\nWriteStream. If the pattern is reached, leave the pattern\non the internal buffer, disconnect the pipe, and call end()\non the destination. Back-pressure is properly managed.\n\n__Arguments__\n\n* destination - The Stream to pipe data to\n* options (optional)\n    * end Boolean Default=false\n\n__Return__\n\nStream - the destination stream\n\n__Example__\n\n```javascript\nvar us = new UntilStream({ pattern: '\\n' });\nvar loremIpsumStream = fs.createReadStream('loremIpsum.txt');\nvar outputStream = fs.createWriteStream(path.join(__dirname, 'loremIpsum.out'));\n\nloremIpsumStream.pipe(us).pipe(outputStream).on('close', function() {\n  console.log('single line of Lorem Ipsum written to disk');\n});\n```\n\n<a name=\"untilStreamReconfigure\" />\n### us.reconfigure([options])\n\nReconfigure the pattern option. It's unwise to call this method\nwhile piping to a destination stream.\n\n__Arguments__\n\n* options (optional)\n    * pattern - String or Buffer If provided, UntilStream will\n                stop reads or pipes when reached\n\n__Example__\n\n```javascript\nvar us = new UntilStream();\n\nus.write(\"Hello\\nWorld\");\nus.reconfigure({ pattern: '\\n' });\nvar hello = us.read();\nconsole.log(hello.toString('utf8'));\nus.read(); //matches '\\n' pattern!\nvar world = us.read();\nconsole.log(world.toString('utf8'));\n```\n\n## License\n\nMIT\n",
  "_id": "until-stream@0.2.2",
  "_from": "until-stream@~0.2.2"
}
